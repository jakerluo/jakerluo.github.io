### 模块化是什么(两种解释)

1. 模块化是一种管理方式，一种生产方式，一种解决问题的方法，一个模块就是实现一种功能的一个或多个文件，有了模块我们就可以用更方便的使用别人的代码，加载别人的模块。但是模块开发需要一定的规范，不然容易乱套。所以就有了后来的 cmd, amd 规范
2. 将一个复杂的应用，根据一定的规则或规范，拆分成 1 个或多个块 或 文件，并进行组合在一起。块的内部属性和实现是私有的，只向外提供一些接口或方法，供外部调用

### 模块化的发展

1. 全局函数

   解释：将不同的功能封装到不同的全局函数内部中

   弊端：由于都放在全局的环境中, 污染全局命名空间， 模块之前看不出关联关系

2. namespace 的简单对象封装

   解释：将一个功能模块的所有方法和属性放到一个对象中去

   作用：解决了命名冲突

   弊端：数据不够安全，外部可以直接修改对象的属性和方法

3. IIFE 模式，匿名函数自调用

   作用：数据放到匿名函数内部，外部只通过向外提供的接口进行操作

   弊端：难以处理多个模块之间依赖关系（jquery）

#### 为什么要有模块化

使用模块化带来的好处：

1. 解决命名冲突

2. 提高可复用性

3. 提高代码的可维护性

4. 灵活架构，焦点分离，方便模块间的分离与组合(按需加载雏形)

5. 多人协作互不干扰

### 模块化规范：

1.  AMD

    规范：采用异步方式加载模块，模块的加载并不影响它后面模块的执行，所有依赖这个模块的语句，都定义在一个回调函数里。等模块加载完毕之后，回调函数才会执行。

    语法：用 `require.config` 指定模块加载的根路径， `define(module_id, deps, callback)` 来定义模块。 `require(modules, callback)` 来加载模块并执行回调函数

2.  CMD

    规范：依赖就近，延迟执行

    语法： 用`define(function(require, export, module){})` 定义模块， 用 `require('')` 加载指定模块文件， 用`seajs.use('')` 定义初始模块内容

3.  commonjs

    规范：Node 应用是由模块组成的，采用 Commonjs 规范。每个文件就是一个模块，有自己的作用域，在一个文件内定义函数，变量，类，都是私有的，对其他文件不可见。
    在服务器端，模块的加载是运行时同步执行的。而在浏览器端，模块是需要提前编译打包处理的。

    特点：

    1. 所有的代码都是运行在模块作用域中，不会污染全局作用域
    2. 模块可以被多次加载，但是只是在第一次加载时运行，其结果就被缓存下来的了，以后在加载就会读缓存结果，要想让模块重新加载运行，必须要清楚缓存
    3. 模块的加载顺序是按照其在代码中出现的顺序

    语法：

    1. 导出 `module.exports = xxxx` 或者 `export.xxx = xxxx`
    2. 引入 `require('xxx')` 如果是第三方模块，则加载的是模块名，如果是自定义模块，则为文件路径
    3. require 用于加载模块文件，require 的作用是读取并执行一个 JavaScript 文件，然后返回该模块的 exports 对象，如果没有找到指定对象，就会报错

    加载机制：

    1. commonjs 加载模块的机制是，输入是被输出的值的拷贝，一旦输出一个值，模块内部的变化将影响不到这个值。
    2. 遇到循环依赖时，如果 a require b, 同时 b require a, nodejs 在执行 a 的时候，就已经把 a 缓存了，但此时只是一个未完工的缓存，所以在 b 中使用 a 时只能拿到一个未完工的空对象，
       解决方案就是先导出自身

4.  es6 module

    概念：设计思想就是模块静态化， 使得在打包编译时就能确定其依赖关系，以及输入输出时的变量

    语法：export 用于规定模块对外的接口，import 用于输入其它模块的功能

    注意点： 使用默认导出时，import 命令可以为该隐匿函数指定任意名字

    区别：ES6 Module 与 commonjs 差异

    1. commonjs 输入输出是值的 copy
    2. commonjs 是运行时加载，es6 module 是编译时输出接口
       > 该差异是因为 commonjs 加载的是一个对象，该对象只在脚本运行时才会生成，而 es6 module 不是对象，它的接口是一种静态定义，在代码解析阶段就会生成。
       > es6 的模块是动态引用，并不会缓存值，模块里面的变量绑定其所在模块

### 总结

- commonjs 主要用于服务端编程，加载模块是同步的，并不适用于浏览器，因为同步意味着阻塞，而浏览器的资源是异步加载的，所以有 AMD, CMD 规范。
- AMD 规范在浏览器中异步加载模块，而且可以并行加载多个模块，不过 amd 规范开发成本比较高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅
- CMD 规范与 AMD 非常相似，都属于浏览器编程，提倡，依赖就近，延迟执行，很容易在 nodejs 里运行，不过模块加载逻辑过重。
- ES6 在语言标准层面上，实现里模块功能，而且相当简单，完全可以替代 commonjs 和 AMD 规范，用于服务器和浏览器的通用模块规范

### es6module 与 commonjs 区别

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJs 是单个值导出，ES6 Module 可以导出多个
4. CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
5. CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined
6. CommonJs 不支持 tree shaking，ES6 Module 支持 tree shaking （打包工具静态分析）
